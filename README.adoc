= aLib for ReScript (alib-for-rescript)
:toc: macro
:toclevels: 3
:sectanchors:
:icons: font

A practical aLib implementation for the ReScript ecosystem: a *proving ground + adapter layer* that brings together ReScript’s stdlib direction, Melange compatibility, and optional runtime validation (Proven) — without replacing upstream standard libraries.

toc::[]

== Status
Alpha / opt-in / namespaced.

== The promise (anti-tears contract)
*Not a replacement stdlib.*

This project is:

* Namespaced (`Aggregate.*` or `Alib.*`) to avoid shadowing upstream modules.
* Upstream-first: upstream stdlibs remain the source of truth.
* Delete-friendly: modules can graduate upstream or be removed if the experiment isn’t valuable.
* Optional validation: Proven integration is opt-in and can be removed without changing core APIs.

== What this repo is
This repo is an ecosystem *implementation* of the aLib method:

* A “Common” layer that is practical for *ReScript + Melange* workflows.
* A “Specific” layer for ReScript ergonomics and higher-level utilities.
* Compatibility adapters so real projects can adopt one module at a time.

It is designed to:

* reduce duplication between ReScript/Melange-targeted projects,
* provide safer interop boundaries,
* and create a low-risk proving ground for improvements that might later be proposed upstream.

== What this repo is NOT
* Not “the new ReScript standard library”.
* Not a fork of upstream stdlibs.
* Not a mandate for the compiler team.
* Not a requirement for library authors.

== Relationship to upstream
ReScript and Melange both ship/expect standard library surfaces (with ecosystem-specific packaging and integration details). :contentReference[oaicite:1]{index=1}

This project sits *beside* them:

* uses upstream types where appropriate,
* provides adapters where the build/runtime packaging differs,
* and keeps experiments namespaced and reversible.

== Proven integration
Proven is supported as an *optional* runtime validation layer for risky boundaries (FFI, untyped JSON, external data).

ReScript bindings exist as `@hyperpolymath/proven-rescript`. :contentReference[oaicite:2]{index=2}

Rules:

* Proven entrypoints are opt-in.
* Validation-heavy APIs are documented as such.
* The “no-Proven path” remains first-class.

== Repo structure
[source]
----
alib-for-rescript/
  README.adoc
  packages/
    common/         # shared across ReScript + Melange constraints
    rescript/       # ReScript-specific utilities and ergonomics
    melange/        # Melange adapters and shims
    proven/         # optional Proven schemas/adapters
    compat/         # to/from upstream conversions, escape hatches
  docs/
    ALPHA.adoc
    MIGRATION_GUIDE.adoc
    DESIGN_NOTES.adoc
  tests/
    compat/         # “must behave like upstream” checks
    property/       # fuzz/generative tests (where useful)
  scripts/
    codemods/       # optional migration helpers
----

== Adoption strategy
*Per-file adoption.*

1. Use one namespaced module in one file.
2. Keep upstream stdlib everywhere else.
3. Convert to/from upstream types only at boundaries.
4. If you stop using aLib, remove it cleanly.

== Graduation policy
A module can be:

* Experimental: iterate quickly (namespaced).
* Stable: semver discipline + tests.
* Proposed: RFC upstream (ReScript/Melange as appropriate).
* Upstreamed: deprecated + removed here to avoid duplication.
* Retained: stays here only if it’s inherently ecosystem glue (adapters, codemods, boundary helpers).

== Why this exists
The aLib method repo (`aggregate-library`) demonstrates overlap + stress testing.
This repo applies the method to real ReScript ecosystem needs:
Proven integration, Melange compatibility, and practical “Common + Specific” boundaries.

== Contributing
Contributions should minimize maintenance burden:

* small modules,
* explicit upstream mapping,
* tests that clarify intent,
* and reversible changes.

== License
(TODO)
